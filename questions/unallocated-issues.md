### Архитектура, микрофронтенды, eslint

## 1 **Архитектура проекта и ее отличие от структуры**

### **Что такое архитектура проекта?**
Архитектура проекта — это высокоуровневая организация системы, которая определяет:
- Основные компоненты и их взаимодействие.
- Принципы разделения ответственности.
- Подходы к масштабированию и поддержке.

Архитектура отвечает на вопросы:
- Как данные будут передаваться между компонентами?
- Как система будет масштабироваться?
- Какие технологии и паттерны будут использоваться?

### **Отличие архитектуры от структуры**
- **Архитектура:** Определяет **как** система работает и взаимодействует на высоком уровне.
- **Структура:** Определяет **где** находятся файлы и папки в проекте (например, `src/components`, `src/utils`).

Пример:
- Архитектура: MVC (Model-View-Controller).
- Структура: Папки `models`, `views`, `controllers`.

### **Какие архитектуры использовал?**
1. **MVC (Model-View-Controller):**
   - **Model:** Отвечает за данные и бизнес-логику.
   - **View:** Отвечает за отображение данных.
   - **Controller:** Связывает Model и View, обрабатывает пользовательский ввод.

2. **MVVM (Model-View-ViewModel):**
   - **Model:** Данные и бизнес-логика.
   - **View:** Интерфейс пользователя.
   - **ViewModel:** Связывает View и Model, предоставляет данные для отображения.

3. **Flux/Redux:**
   - **Односторонний поток данных:** Action → Dispatcher → Store → View.
   - Используется в React-приложениях для управления состоянием.

4. **Микрофронтенды:**
   - Разделение приложения на независимые части, каждая из которых разрабатывается и развертывается отдельно.

5. **Сервис-ориентированная архитектура (SOA):**
   - Приложение разделено на независимые сервисы, которые взаимодействуют через API.

6. **Монолитная архитектура:**
   - Все компоненты системы tightly coupled (тесно связаны) и развертываются как единое целое.

### **Примеры использования**
- **MVC:** Традиционные веб-приложения (Ruby on Rails, Django).
- **Redux:** React-приложения с большим количеством состояния.
- **Микрофронтенды:** Крупные проекты с несколькими командами разработчиков.
- **SOA:** Микросервисы в backend-разработке.

### **Итог**
Архитектура проекта — это фундамент, который определяет, как система будет работать и развиваться. Выбор архитектуры зависит от масштаба проекта, команды и требований.


## 2. **Что такое микрофронтенды?**

Микрофронтенды — это архитектурный подход к разработке фронтенда, при котором веб-приложение разбивается на небольшие, независимые части (микрофронтенды). Каждая часть отвечает за отдельную функциональность и может разрабатываться, тестироваться и развертываться независимо.

### **Преимущества микрофронтендов:**
- **Независимость команд:** Каждая команда может работать над своим микрофронтендом, используя свои технологии и инструменты.
- **Масштабируемость:** Упрощается поддержка и масштабирование больших приложений.
- **Постепенное обновление:** Возможность обновлять части приложения без полного переписывания.

### **Недостатки микрофронтендов:**
- **Сложность интеграции:** Требуется тщательная настройка взаимодействия между микрофронтендами.
- **Производительность:** Возможны накладные расходы из-за загрузки нескольких микрофронтендов.
- **Сложность отладки:** Усложняется процесс отладки и тестирования из-за распределенной архитектуры.

### **Пример использования:**
- Крупные приложения, такие как интернет-магазины, где разные команды работают над корзиной, каталогом, личным кабинетом и т.д.

## **Зачем нужен ESLint, настройка и плагины**

## 3. **Что такое ESLint?**
ESLint — это инструмент для статического анализа кода, который помогает находить и исправлять ошибки, а также обеспечивать соблюдение стиля написания кода. Он поддерживает JavaScript, TypeScript и другие языки.

### **Зачем нужен ESLint?**
1. **Обнаружение ошибок:** Помогает находить синтаксические ошибки и потенциальные баги до запуска кода.
2. **Соблюдение стиля:** Обеспечивает единый стиль написания кода в команде.
3. **Автоматическое исправление:** Многие ошибки и стилевые проблемы могут быть автоматически исправлены.
4. **Поддержка современных стандартов:** Поддерживает новые возможности JavaScript (ES6+).
5. **Интеграция с IDE:** Работает в большинстве редакторов кода, предоставляя подсказки и исправления в реальном времени.

### **Настройка ESLint**
ESLint настраивается через конфигурационный файл (`.eslintrc.js`, `.eslintrc.json` или `.eslintrc.yml`). В нем указываются:
- **Правила (rules):** Какие ошибки искать и как их обрабатывать.
- **Окружение (env):** Глобальные переменные (например, `browser`, `node`).
- **Парсер (parser):** Например, `@babel/eslint-parser` или `@typescript-eslint/parser` для TypeScript.
- **Расширения (extends):** Готовые конфигурации, такие как `eslint:recommended` или `airbnb`.

### ООП, паттерны, классы под капотом

## 1. **Что такое ООП?**

ООП (Объектно-Ориентированное Программирование) — это парадигма программирования, основанная на концепции объектов, которые содержат данные и методы для работы с этими данными. ООП позволяет структурировать код, делая его более модульным, понятным и легко поддерживаемым.

###  **Основные принципы ООП**
1. **Инкапсуляция:**
   - Сокрытие внутренней реализации объекта и предоставление только необходимого интерфейса.
   - Пример: Класс с приватными полями и публичными методами для доступа к ним.

2. **Наследование:**
   - Возможность создания нового класса на основе существующего, с повторным использованием его свойств и методов.
   - Пример: Класс `Animal` может быть унаследован классом `Dog`.

3. **Полиморфизм:**
   - Возможность объектов с одинаковым интерфейсом вести себя по-разному.
   - Пример: Метод `makeSound()` может по-разному работать для классов `Dog` и `Cat`.

4. **Абстракция:**
   - Упрощение сложных систем путем выделения только важных характеристик объекта.
   - Пример: Класс `Car` может абстрагироваться от деталей двигателя, предоставляя только методы для управления.
  
## 2. **Паттерны проектирования**

### **1. Порождающие**
- **Singleton:** Один экземпляр класса.
- **Factory:** Создание объектов без указания класса.
- **Builder:** Пошаговое создание сложных объектов.
- **Prototype:** Клонирование объектов.
- **Abstract Factory:** Создание семейств связанных объектов.

### **2. Структурные**
- **Adapter:** Совмещение несовместимых интерфейсов.
- **Decorator:** Добавление функциональности объекту.
- **Facade:** Упрощение взаимодействия с системой.
- **Proxy:** Контроль доступа к объекту.
- **Composite:** Работа с группой объектов как с одним.

### **3. Поведенческие**
- **Observer:** Уведомление об изменениях.
- **Strategy:** Выбор алгоритма на лету.
- **Command:** Инкапсуляция запросов в объекты.
- **Iterator:** Последовательный обход коллекции.
- **State:** Изменение поведения в зависимости от состояния.
- **Chain of Responsibility:** Передача запросов по цепочке.
- **Template Method:** Скелет алгоритма с изменяемыми шагами.
- **Mediator:** Централизованное управление взаимодействием.
- **Memento:** Сохранение и восстановление состояния.
- **Visitor:** Добавление операций без изменения классов.

## 3. **Как работают классы под капотом? Прототипы**

### **Классы в JavaScript**
Классы в JavaScript — это синтаксический сахар над прототипным наследованием. Они упрощают создание объектов и работу с наследованием, но под капотом всё равно используются прототипы.

### **Прототипное наследование**
- Каждый объект в JavaScript имеет скрытое свойство `[[Prototype]]`, которое ссылается на другой объект (прототип).
- Если свойство или метод не найдены в объекте, JavaScript ищет их в прототипе (цепочка прототипов).
- Прототип можно задать с помощью `Object.create()` или через свойство `__proto__`.


### Git

## 1. **Git Flow и GitHub Flow**

### **Git Flow**
Git Flow — это модель ветвления для Git, которая использует несколько типов веток для управления разработкой. Она подходит для проектов с четкими этапами выпуска (релизами).

#### **Основные ветки:**
1. **`main` (или `master`):** Содержит стабильный код, готовый к релизу.
2. **`develop`:** Ветка для текущей разработки. Все фичи и исправления сливаются сюда.

#### **Вспомогательные ветки:**
1. **`feature/`:** Для разработки новых функций. Создаются от `develop`, сливаются обратно в `develop`.
2. **`release/`:** Для подготовки к релизу. Создаются от `develop`, сливаются в `main` и `develop`.
3. **`hotfix/`:** Для срочных исправлений в `main`. Создаются от `main`, сливаются в `main` и `develop`.

### **GitHub Flow**
GitHub Flow — это упрощенная модель ветвления, ориентированная на непрерывную интеграцию и доставку. Подходит для проектов с частыми обновлениями.

#### **Основные принципы:**
1. **`main`:** Всегда содержит рабочий код, готовый к развертыванию.
2. **Ветки для фич:** Создаются от `main` для каждой задачи или фичи.
3. **Pull Request (PR):** Изменения проверяются через PR перед слиянием в `main`.
4. **Непрерывное развертывание:** После слияния в `main` код сразу развертывается.
   
## **Как минимизировать количество merge-конфликтов?**

### **1. Частые слияния**
### **2. Маленькие и атомарные коммиты**
### **3. Использование Pull Requests (PR)**
### **4. Четкое разделение обязанностей**
### **5. Использование инструментов**
- **Git rebase:** Перебазируйте свою ветку на актуальную основную ветку перед слиянием.
- **Git merge --no-ff:** Используйте слияние с явным созданием merge-коммита для сохранения истории.
### **6. Автоматизация**
- Настройте CI/CD для автоматического тестирования и проверки конфликтов.
- Используйте инструменты для автоматического разрешения конфликтов (например, `git rerere`).
### **7. Коммуникация в команде**
### **8. Чистый код**
- Следуйте принципам SOLID и DRY.
- Избегайте дублирования кода и сложных зависимостей.
  
## **3. Отличие merge и rebase**

### **Merge (Слияние)**
- Создает новый merge-коммит, который объединяет две ветки.
- Сохраняет полную историю, включая все коммиты из обеих веток.
- Подходит для публичных веток (например, `main` или `develop`).

### **Rebase (Перебазирование)**
- Перемещает коммиты одной ветки на верх другой ветки, создавая линейную историю.
- Упрощает историю, но изменяет хэши коммитов.
- Подходит для локальных веток перед слиянием в основную.

---

## **4. Зачем нужны git hooks (pre-commit и др.)?**

### **Git Hooks**
- Скрипты, которые автоматически выполняются при определенных событиях в Git (например, коммит, пуш).
- **Примеры:**
  - **pre-commit:** Проверка кода перед созданием коммита (например, линтинг, тесты).
  - **pre-push:** Проверка перед отправкой изменений на сервер.
  - **commit-msg:** Проверка формата сообщения коммита.

### **Зачем нужны?**
- Автоматизация рутинных задач (линтеры, тесты).
- Обеспечение качества кода перед коммитом или пушем.
- Соблюдение стандартов (например, формат сообщений коммитов).

---

## **5. Что такое code review и зачем оно нужно?**

### **Code Review**
- Процесс проверки кода другими разработчиками перед слиянием в основную ветку.
- Проводится через Pull Request (PR) или Merge Request (MR).

### **Зачем нужно?**
- **Качество кода:** Выявление ошибок, багов и уязвимостей.
- **Обучение:** Обмен знаниями и опытом в команде.
- **Стандарты:** Соблюдение стиля и архитектурных принципов.
- **Улучшение кода:** Получение обратной связи и предложений по улучшению.

### **Плюсы:**
- Уменьшение количества багов.
- Повышение читаемости и поддерживаемости кода.
- Укрепление командной работы.


## **2. Работа с access token в React/Redux**
- **Хранение:** Redux Store или Context API.
- **Обновление:** Кастомный middleware для автоматического обновления токена.

---

## **15. RTK Query**
- **Что:** Инструмент для API-запросов в Redux Toolkit.
- **Плюсы:** Кеширование, минимум boilerplate.
- **Минусы:** Избыточность для простых проектов.

---

## **7. Блочные vs строчные элементы**
- **Блочные:** Занимают всю ширину, новая строка (`<div>`, `<p>`).
- **Строчные:** Только необходимая ширина, в строке (`<span>`, `<a>`).

---

## **8. Композиция**
- **Что:** Сборка сложных объектов из простых.
- **Реализация:** Использование компонентов или функций, которые комбинируют другие компоненты/функции.

---

## **9. Карирование**
- **Что:** Преобразование функции с множеством аргументов в последовательность функций с одним аргументом.
- **Реализация:**
  ```javascript
  const add = a => b => a + b;
  const add5 = add(5);
  console.log(add5(3)); // 8


